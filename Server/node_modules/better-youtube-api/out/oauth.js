"use strict";
/* istanbul ignore file */
/* We ignore this file because OAuth endpoints are too taxing to test, they are instead manually tested. */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("./util");
const entities_1 = require("./entities");
const constants_1 = require("./constants");
class OAuth {
    /**
     *
     * @param youtube The YouTube object to retrieve the token from.
     */
    constructor(youtube) {
        this.youtube = youtube;
    }
    checkTokenAndThrow() {
        if (this.youtube.tokenType !== 'oauth') {
            throw new Error('Token is not an oauth token');
        }
    }
    // tslint:disable:no-trailing-whitespace
    /**
     * Post a comment on a video or channel discussion.
     * Last tested 09/26/2019 06:02. PASSING
     * @param text The text content of the comment.
     * @param channelId The channel to post the comment on.
     * @param videoId The video of the channel to post the comment on.
     * If falsey, the comment will be posted to the channel discussion.
     */
    // tslint:enable:no-trailing-whitespace
    postComment(text, channelId, videoId) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkTokenAndThrow();
            if (text === undefined || text === null || text.trim() === '') {
                return Promise.reject('Invalid comment text');
            }
            const data = JSON.parse(JSON.stringify(constants_1.CommentThreadData));
            data.snippet.topLevelComment.snippet.textOriginal = text;
            data.snippet.channelId = channelId;
            if (videoId) {
                data.snippet.videoId = videoId;
            }
            const result = yield this.sendData('post', 'commentThreads', 'snippet', data);
            const type = result.snippet.channelId ? 'channel' : 'video';
            return new entities_1.YTComment(this.youtube, result.snippet.topLevelComment, type);
        });
    }
    // tslint:disable:no-trailing-whitespace
    /**
     * Edit a comment on a video or channel discussion.
     * Last tested 09/26/2019 06:23. PASSING
     * @param text The new text content of the comment.
     * @param commentId The ID of the comment.
     */
    // tslint:enable:no-trailing-whitespace
    editComment(text, commentId) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkTokenAndThrow();
            if (text === undefined || text === null || text.trim() === '') {
                return Promise.reject('Invalid comment text');
            }
            const data = JSON.parse(JSON.stringify(constants_1.CommentThreadData));
            data.snippet.topLevelComment.snippet.textOriginal = text;
            data.id = commentId;
            const result = yield this.sendData('put', 'commentThreads', 'snippet', data);
            const type = result.snippet.channelId ? 'channel' : 'video';
            const comment = new entities_1.YTComment(this.youtube, result.snippet.topLevelComment, type);
            if (result.replies) {
                result.replies.comments.forEach(reply => {
                    const created = new entities_1.YTComment(this.youtube, reply, type);
                    comment.replies.push(created);
                });
            }
            return comment;
        });
    }
    sendData(type, endpoint, part, data) {
        return util_1.request[type](endpoint, { part }, this.youtube.token, JSON.stringify(data));
    }
}
exports.OAuth = OAuth;

//# sourceMappingURL=oauth.js.map
