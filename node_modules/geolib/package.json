{
  "_from": "geolib",
  "_id": "geolib@3.1.0",
  "_inBundle": false,
  "_integrity": "sha512-46P2RFHUskJGVi8jE389tK2CPmpnpU+7bRr3hQks7ojU7dEqtqKbih+yB1nBXTTpUUt47VPen16oMV3P6IRQyg==",
  "_location": "/geolib",
  "_phantomChildren": {},
  "_requested": {
    "escapedName": "geolib",
    "fetchSpec": "latest",
    "name": "geolib",
    "raw": "geolib",
    "rawSpec": "",
    "registry": true,
    "saveSpec": null,
    "type": "tag"
  },
  "_requiredBy": [
    "#USER"
  ],
  "_resolved": "https://registry.npmjs.org/geolib/-/geolib-3.1.0.tgz",
  "_shasum": "c2b5124105f2cc37f097700f8ec63e65c7061920",
  "_spec": "geolib",
  "_where": "C:\\Users\\riccardo\\Desktop\\riccardo\\WMI-smogBranch",
  "author": {
    "name": "Manuel Bieh"
  },
  "bugs": {
    "url": "https://github.com/manuelbieh/geolib/issues"
  },
  "bundleDependencies": false,
  "dependencies": {},
  "deprecated": false,
  "description": "[![CircleCI](https://circleci.com/gh/manuelbieh/geolib/tree/master.svg?style=svg)](https://circleci.com/gh/manuelbieh/geolib/tree/master) ![](https://badgen.net/bundlephobia/minzip/geolib) ![](https://badgen.net/npm/dm/geolib) ![](https://badgen.net/github/license/manuelbieh/geolib) [![styled with prettier](https://img.shields.io/badge/styled_with-prettier-ff69b4.svg)](https://github.com/prettier/prettier)",
  "devDependencies": {
    "@babel/cli": "^7.4.4",
    "@babel/core": "^7.4.4",
    "@babel/preset-env": "^7.4.4",
    "@babel/preset-typescript": "^7.3.3",
    "@semantic-release/git": "^7.0.8",
    "@semantic-release/npm": "^5.1.7",
    "@types/jest": "^24.0.12",
    "@types/node": "^12.0.0",
    "@typescript-eslint/eslint-plugin": "^1.7.0",
    "@typescript-eslint/parser": "^1.7.0",
    "babel-eslint": "^10.0.1",
    "babel-jest": "^24.8.0",
    "babel-loader": "^8.0.6",
    "eslint": "^5.16.0",
    "eslint-config-prettier": "^4.2.0",
    "eslint-config-wiremore": "^3.0.2",
    "eslint-import-resolver-typescript": "^1.1.1",
    "eslint-plugin-babel": "^5.2.0",
    "eslint-plugin-import": "^2.17.2",
    "eslint-plugin-prettier": "^3.0.1",
    "eslint-plugin-react": "^7.12.4",
    "eslint-plugin-react-hooks": "^1.6.0",
    "eslint-plugin-security": "^1.4.0",
    "eslint-plugin-unicorn": "^8.0.2",
    "husky": "^2.2.0",
    "jest": "^24.8.0",
    "lint-staged": "^8.1.6",
    "prettier": "^1.17.0",
    "rimraf": "^2.6.3",
    "semantic-release": "^15.13.12",
    "semantic-release-conventional-commits": "^2.0.1",
    "typescript": "^3.4.5",
    "webpack": "^4.30.0",
    "webpack-cli": "^3.3.2"
  },
  "files": [
    "es",
    "lib"
  ],
  "homepage": "https://github.com/manuelbieh/geolib#readme",
  "license": "MIT",
  "main": "lib/index.js",
  "module": "es/index.js",
  "name": "geolib",
  "optionalDependencies": {},
  "readme": "# Geolib\n\n[![CircleCI](https://circleci.com/gh/manuelbieh/geolib/tree/master.svg?style=svg)](https://circleci.com/gh/manuelbieh/geolib/tree/master)\n![](https://badgen.net/bundlephobia/minzip/geolib)\n![](https://badgen.net/npm/dm/geolib)\n![](https://badgen.net/github/license/manuelbieh/geolib)\n[![styled with prettier](https://img.shields.io/badge/styled_with-prettier-ff69b4.svg)](https://github.com/prettier/prettier)\n\nLibrary to provide basic geospatial operations like distance calculation, conversion of decimal coordinates to sexagesimal and vice versa, etc. This library is currently **2D**, meaning that altitude/elevation is not yet supported by any of its functions!\n\n## Changelog\n\nA detailed changelog can be found in [CHANGELOG.md](./CHANGELOG.md)\n\n## Install\n\n```sh\nnpm install geolib\n```\n\n```sh\nyarn add geolib\n```\n\n## Usage\n\nThere is a **UMD** build and an **ES Module** build. You can either use the UMD build in Node like any other library:\n\n```js\nconst geolib = require('geolib');\n```\n\nor in the browser by using a simple script element:\n\n```html\n<script src=\"lib/geolib.js\"></script>\n```\n\nIf you load it in the browser, you can access all the functions via `window.geolib`.\n\nIf you're working with a bundler (like Webpack or Parcel) or have an environment that supports ES Modules natively, you can either import certain functions from the package directly:\n\n```js\nimport { getDistance } from 'geolib';\n```\n\nor load the whole library:\n\n```js\nimport * as geolib from 'geolib';\n```\n\nor you can import single functions directly to potentially make use of treeshaking (recommended):\n\n```js\nimport getDistance from 'geolib/es/getDistance';\n```\n\n## General\n\nThis library is written in TypeScript. You don't have to know TypeScript to use Geolib but the [type definitions](./src/types.ts) give you valuable information about the general usage, input parameters etc.\n\n### Supported values and formats\n\nAll methods that are working with coordinates accept either an object with a `lat`/`latitude` **and** a `lon`/`lng`/`longitude` property, **or** a GeoJSON coordinates array, like: `[lon, lat]`. All values can be either in decimal (`53.471`) or sexagesimal (`53° 21' 16\"`) format.\n\nDistance values are **always** floats and represent the distance in **meters**.\n\n## Functions\n\n### `getDistance(start, end, accuracy = 1)`\n\nCalculates the distance between two geo coordinates.\n\nThis function takes up to 3 arguments. First 2 arguments must be valid `GeolibInputCoordinates` (e.g. `{latitude: 52.518611, longitude: 13.408056}`). Coordinates can be in sexagesimal or decimal format. The third argument is accuracy (in meters). By default the accuracy is 1 meter. If you need a more accurate result, you can set it to a lower value, e.g. to `0.01` for centimeter accuracy. You can set it higher to have the result rounded to the next value that is divisible by your chosen accuracy (e.g. `25428` with an accuracy of `100` becomes `25400`).\n\n```js\ngetDistance(\n    { latitude: 51.5103, longitude: 7.49347 },\n    { latitude: \"51° 31' N\", longitude: \"7° 28' E\" }\n);\n```\n\n```js\n// Working with W3C Geolocation API\nnavigator.geolocation.getCurrentPosition(\n    function(position) {\n        console.log(\n            'You are ',\n            geolib.getDistance(position.coords, {\n                latitude: 51.525,\n                longitude: 7.4575,\n            }),\n            'meters away from 51.525, 7.4575'\n        );\n    },\n    () => {\n        alert('Position could not be determined.');\n    }\n);\n```\n\nReturns the distance in meters as a numeric value.\n\n### `getPreciseDistance(start, end[, int accuracy])`\n\nCalculates the distance between two geo coordinates. This method is more accurate then `getDistance`, especially for long distances but it is also slower. It is using the Vincenty inverse formula for ellipsoids.\n\nIt takes the same (up to 3) arguments as `getDistance`.\n\n```js\ngeolib.getPreciseDistance(\n    { latitude: 51.5103, longitude: 7.49347 },\n    { latitude: \"51° 31' N\", longitude: \"7° 28' E\" }\n);\n```\n\n### `getCenter(coords)`\n\nCalculates the geographical center of all points in a collection of geo coordinates. Takes an array of coordinates and calculates the center of it.\n\n```js\ngeolib.getCenter([\n    { latitude: 52.516272, longitude: 13.377722 },\n    { latitude: 51.515, longitude: 7.453619 },\n    { latitude: 51.503333, longitude: -0.119722 },\n]);\n```\n\nReturns an object:\n\n```js\n{\n    \"latitude\": centerLat,\n    \"longitude\": centerLon\n}\n```\n\n### `getCenterOfBounds(coords)`\n\nCalculates the center of the bounds of geo coordinates.\n\nTakes an array of coordinates, calculate the border of those, and gives back the center of that rectangle.\n\nOn polygons like political borders (eg. states), this may gives a closer result to human expectation, than `getCenter`, because that function can be disturbed by uneven distribution of point in different sides.\n\nImagine the US state Oklahoma: `getCenter` on that gives a southern point, because the southern border contains a lot more nodes, than the others.\n\n```js\ngeolib.getCenterOfBounds([\n    { latitude: 51.513357512, longitude: 7.45574331 },\n    { latitude: 51.515400598, longitude: 7.45518541 },\n    { latitude: 51.516241842, longitude: 7.456494328 },\n    { latitude: 51.516722545, longitude: 7.459863183 },\n    { latitude: 51.517443592, longitude: 7.463232037 },\n]);\n```\n\nReturns an object:\n\n```js\n{\n    \"latitude\": centerLat,\n    \"longitude\": centerLng\n}\n```\n\n### `getBounds(points)`\n\nCalculates the bounds of geo coordinates.\n\n```js\ngeolib.getBounds([\n    { latitude: 52.516272, longitude: 13.377722 },\n    { latitude: 51.515, longitude: 7.453619 },\n    { latitude: 51.503333, longitude: -0.119722 },\n]);\n```\n\nIt returns minimum and maximum latitude and minimum and maximum longitude as an object:\n\n```js\n{\n    \"minLat\": minimumLatitude,\n    \"maxLat\": maximumLatitude,\n    \"minLng\": minimumLongitude,\n    \"maxLng\": maximumLongitude,\n}\n```\n\n### `isPointInPolygon(point, polygon)`\n\nChecks whether a point is inside of a polygon or not.\n\n```js\ngeolib.isPointInPolygon({ latitude: 51.5125, longitude: 7.485 }, [\n    { latitude: 51.5, longitude: 7.4 },\n    { latitude: 51.555, longitude: 7.4 },\n    { latitude: 51.555, longitude: 7.625 },\n    { latitude: 51.5125, longitude: 7.625 },\n]);\n```\n\nReturns `true` or `false`\n\n### `isPointWithinRadius(point, centerPoint, radius)`\n\nChecks whether a point is inside of a circle or not.\n\n```js\n// checks if 51.525/7.4575 is within a radius of 5 km from 51.5175/7.4678\ngeolib.isPointWithinRadius(\n    { latitude: 51.525, longitude: 7.4575 },\n    { latitude: 51.5175, longitude: 7.4678 },\n    5000\n);\n```\n\nReturns `true` or `false`\n\n### `getRhumbLineBearing(origin, destination)`\n\nGets rhumb line bearing of two points. Find out about the difference between rhumb line and great circle bearing on Wikipedia. Rhumb line should be fine in most cases:\n\nhttp://en.wikipedia.org/wiki/Rhumb_line#General_and_mathematical_description\n\nFunction is heavily based on Doug Vanderweide's great PHP version (licensed under GPL 3.0)\nhttp://www.dougv.com/2009/07/13/calculating-the-bearing-and-compass-rose-direction-between-two-latitude-longitude-coordinates-in-php/\n\n```js\ngeolib.getRhumbLineBearing(\n    { latitude: 52.518611, longitude: 13.408056 },\n    { latitude: 51.519475, longitude: 7.46694444 }\n);\n```\n\nReturns calculated bearing as number.\n\n### `getGreatCircleBearing(origin, destination)`\n\nGets great circle bearing of two points. This is more accurate than rhumb line bearing but also slower.\n\n```js\ngeolib.getGreatCircleBearing(\n    { latitude: 52.518611, longitude: 13.408056 },\n    { latitude: 51.519475, longitude: 7.46694444 }\n);\n```\n\nReturns calculated bearing as number.\n\n### `getCompassDirection(origin, destination, bearingFunction = getRhumbLineBearing)`\n\nGets the compass direction from an origin coordinate to a destination coordinate. Optionally a function to determine the bearing can be passed as third parameter. Default is `getRhumbLineBearing`.\n\n```js\ngeolib.getCompassDirection(\n    { latitude: 52.518611, longitude: 13.408056 },\n    { latitude: 51.519475, longitude: 7.46694444 }\n);\n```\n\nReturns the direction (e.g. `NNE`, `SW`, `E`, …) as string.\n\n### `orderByDistance(point, arrayOfPoints)`\n\nSorts an array of coords by distance to a reference coordinate.\n\n```js\ngeolib.orderByDistance({ latitude: 51.515, longitude: 7.453619 }, [\n    { latitude: 52.516272, longitude: 13.377722 },\n    { latitude: 51.518, longitude: 7.45425 },\n    { latitude: 51.503333, longitude: -0.119722 },\n]);\n```\n\nReturns an array of points ordered by their distance to the reference point.\n\n### `findNearest(point, arrayOfPoints)`\n\nFinds the single one nearest point to a reference coordinate. It's actually just a convenience method that uses `orderByDistance` under the hood and returns the first result.\n\n```js\ngeolib.findNearest({ latitude: 52.456221, longitude: 12.63128 }, [\n    { latitude: 52.516272, longitude: 13.377722 },\n    { latitude: 51.515, longitude: 7.453619 },\n    { latitude: 51.503333, longitude: -0.119722 },\n    { latitude: 55.751667, longitude: 37.617778 },\n    { latitude: 48.8583, longitude: 2.2945 },\n    { latitude: 59.3275, longitude: 18.0675 },\n    { latitude: 59.916911, longitude: 10.727567 },\n]);\n```\n\nReturns the point nearest to the reference point.\n\n### `getPathLength(points, distanceFunction = getDistance)`\n\nCalculates the length of a collection of coordinates. Expects an array of points as first argument and optionally a function to determine the distance as second argument. Default is `getDistance`.\n\n```js\ngeolib.getPathLength([\n    { latitude: 52.516272, longitude: 13.377722 },\n    { latitude: 51.515, longitude: 7.453619 },\n    { latitude: 51.503333, longitude: -0.119722 },\n]);\n```\n\nReturns the length of the path in meters as number.\n\n### `getDistanceFromLine(point, lineStart, lineEnd)`\n\nGets the minimum distance from a point to a line of two points.\n\n```js\ngeolib.getDistanceFromLine(\n    { latitude: 51.516, longitude: 7.456 },\n    { latitude: 51.512, longitude: 7.456 },\n    { latitude: 51.516, longitude: 7.459 }\n);\n```\n\nReturns the shortest distance to the given line as number.\n\n### `getBoundsOfDistance(point, distance)`\n\nComputes the bounding coordinates of all points on the surface of the earth less than or equal to the specified great circle distance.\n\n```js\ngeolib.getBoundsOfDistance(\n    { latitude: 34.090166, longitude: -118.276736555556 },\n    1000\n);\n```\n\nReturns an array with the southwestern and northeastern coordinates.\n\n### `isPointInLine(point, lineStart, lineEnd)`\n\nCalculates if given point lies in a line formed by start and end.\n\n```js\ngeolib.isPointInLine(\n    { latitude: 0, longitude: 10 },\n    { latitude: 0, longitude: 0 },\n    { latitude: 0, longitude: 15 }\n);\n```\n\n### `sexagesimalToDecimal(value)`\n\nConverts a sexagesimal coordinate into decimal format\n\n```js\ngeolib.sexagesimalToDecimal(`51° 29' 46\" N`);\n```\n\nReturns the new value as decimal number.\n\n### `decimalToSexagesimal(value)`\n\nConverts a decimal coordinate to sexagesimal format\n\n```js\ngeolib.decimalToSexagesimal(51.49611111); // -> 51° 29' 46`\n```\n\nReturns the new value as sexagesimal string.\n\n### `geolib.getLatitude(point, raw = false)`\n\n### `geolib.getLongitude(point, raw = false)`\n\nReturns the latitude/longitude for a given point **and** converts it to decimal. If the second argument is set to true it does **not** convert the value to decimal.\n\n```js\ngeolib.getLatitude({ lat: 51.49611, lng: 7.38896 }); // -> 51.49611\ngeolib.getLongitude({ lat: 51.49611, lng: 7.38896 }); // -> 7.38896\n```\n\nReturns the value as decimal or in its original format if the second argument was set to true.\n\n### `toDecimal(point)`\n\nChecks if a coordinate is already in decimal format and, if not, converts it to. Works with single values (e.g. `51° 32' 17\"`) and complete coordinates (e.g. `{lat: 1, lon: 1}`) as long as it in a [supported format](#supported-values-and-formats).\n\n```js\ngeolib.toDecimal(`51° 29' 46\" N`); // -> 51.59611111\ngeolib.toDecimal(51.59611111); // -> 51.59611111\n```\n\nReturns a decimal value for the given input value.\n\n### `computeDestinationPoint(point, distance, bearing, radius = earthRadius)`\n\nComputes the destination point given an initial point, a distance (in meters) and a bearing (in degrees). If no radius is given it defaults to the mean earth radius of 6,371,000 meters.\n\nAttention: this formula is not _100%_ accurate (but very close though).\n\n```js\ngeolib.computeDestinationPoint(\n    { latitude: 52.518611, longitude: 13.408056 },\n    15000,\n    180\n);\n```\n\n```js\ngeolib.computeDestinationPoint(\n    [13.408056, 52.518611]\n    15000,\n    180\n);\n```\n\nReturns the destination in the same format as the input coordinates. So if you pass a GeoJSON point, you will get a GeoJSON point.\n\n### `getAreaOfPolygon(points)`\n\nCalculates the surface area of a polygon.\n\n```js\ngeolib.getAreaOfPolygon([\n    [7.453635617650258, 51.49320556213869],\n    [7.454583481047989, 51.49328893754685],\n    [7.454778172179346, 51.49240881084831],\n    [7.453832678225655, 51.49231619246726],\n    [7.453635617650258, 51.49320556213869],\n]);\n```\n\nReturns the result as number in square meters.\n\n### `getCoordinateKeys(point)`\n\nGets the property names of that are used in the point in a normalized form:\n\n```js\ngeolib.getCoordinateKeys({ lat: 1, lon: 1 });\n// -> { latitude: 'lat', longitude: 'lon' }\n```\n\nReturns an object with a `latitude` and a `longitude` property. Their values are the property names for latitude and longitude that are used in the passed point. Should probably only be used internally.\n\n### `getCoordinateKey(point, keysToLookup)`\n\nIs used by `getCoordinateKeys` under the hood and returns the property name out of a list of possible names.\n\n```js\ngeolib.getCoordinateKey({ latitude: 1, longitude: 2 }, ['lat', 'latitude']);\n// -> latitude\n```\n\nReturns the name of the property as string or `undefined` if no there was no match.\n\n### `isValidCoordinate(point)`\n\nChecks if a given point has at least a **latitude** and a **longitude** and is in a supported format.\n\n```js\n// true:\ngeolib.isValidCoordinate({ latitude: 1, longitude: 2 });\n\n// false, longitude is missing:\ngeolib.isValidCoordinate({ latitude: 1 });\n\n// true, GeoJSON format:\ngeolib.isValidCoordinate([2, 1]);\n```\n\nReturns `true` or `false`.\n\n### `getSpeed(startPointWithTime, endPointWithTime)`\n\nCalculates the speed between two points within a given time span.\n\n```js\ngeolib.getSpeed(\n    { latitude: 51.567294, longitude: 7.38896, time: 1360231200880 },\n    { latitude: 52.54944, longitude: 13.468509, time: 1360245600880 }\n);\n```\n\nReturn the speed in meters per second as number.\n\n### `convertSpeed(value, unit)`\n\nConverts the result from `getSpeed` into a more human friendly format. Currently available units are `mph` and `kmh`.\n\n#### Units\n\n`unit` can be one of:\n\n-   kmh (kilometers per hour)\n-   mph (miles per hour)\n\n```js\ngeolib.convertSpeed(29.8678, 'kmh'));\n```\n\nReturns the converted value as number.\n\n### `convertDistance(value, unit)`\n\nConverts a given distance (in meters) into another unit.\n\n#### Units\n\n`unit` can be one of:\n\n-   m (meter)\n-   km (kilometers)\n-   cm (centimeters)\n-   mm (millimeters)\n-   mi (miles)\n-   sm (seamiles)\n-   ft (feet)\n-   in (inches)\n-   yd (yards)\n\n```js\ngeolib.convertDistance(14200, 'km'); // 14.2\ngeolib.convertDistance(500, 'km'); // 0.5\n```\n\nReturns the converted distance as number.\n\n### `convertArea(value, unit)`\n\nConverts the result from `getAreaForPolygon` into a different unit.\n\n#### Units\n\n`unit` can be one of:\n\n-   m2, sqm (square meters)\n-   km2, sqkm (square kilometers)\n-   ha (hectares)\n-   a (ares)\n-   ft2, sqft (square feet)\n-   yd2, sqyd (square yards)\n-   in2, sqin (square inches)\n\n```js\ngeolib.convertArea(298678, 'km2'));\n```\n\nReturns the converted area as number.\n\n\n### `wktToPolygon(wkt)`\n\nConverts the Well-known text (a.k.a WKT) to polygon that Geolib understands.\n[https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry#Geometric_Objects](WKT)\n\n```js\ngeolib.wktToPolygon('POLYGON ((30 10.54321, 40 40, 20 40, 10 20, 30 10))');\n// [\n//     { latitude: 10.54321, longitude: 30 },\n//     { latitude: 40, longitude: 40 },\n//     { latitude: 40, longitude: 20 },\n//     { latitude: 20, longitude: 10 },\n//     { latitude: 10, longitude: 30 },}\n// ]\n```\n\nReturns the array of coordinates.\n\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/manuelbieh/geolib.git"
  },
  "scripts": {
    "babel": "babel",
    "build": "yarn clean && yarn build:es && yarn build:types && yarn build:umd",
    "build:es": "babel --minified --ignore **/*.test.js,**/*.test.ts --out-dir es --extensions .ts,.js --no-comments src",
    "build:types": "tsc --outDir es --emitDeclarationOnly --noEmit false --declaration",
    "build:umd": "webpack-cli --config webpack.config.js",
    "clean": "rimraf lib es",
    "lint": "eslint src/**/*.{js,ts}",
    "postrelease": "git pull origin master && git push origin master --follow-tags",
    "release": "semantic-release",
    "test": "jest",
    "typecheck": "tsc --noEmit"
  },
  "type": "module",
  "typings": "es/index.d.ts",
  "version": "3.1.0"
}
